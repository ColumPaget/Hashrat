.TH hashrat "1" "Jan 2015" "HASHRAT 1.5" "hashing tool supporting several hashes and recursivity"
.\"Text automatically generated by txt2man
.SH NAME
\fBhashrat \fP- hashing tool supporting several hashes and recursivity
\fB
.SH SYNOPSIS
.nf
.fam C
\fBhashrat\fP [\fIoptions\fP] [\fIpaths\fP \fIto\fP \fIhash\fP]

\fBhashrat\fP \fB-c\fP [\fIoptions\fP] [\fIinput\fP \fIfile\fP \fIof\fP \fIhashes\fP]

.fam T
.fi
.fam T
.fi
.SH DESCRIPTION
Hashrat is a \fIhash\fP-generation utility that supports the md5, sha1, sha256, sha512, whirlpool, jh-224, jh256, jh-384 and jh-512 \fIhash\fP functions, and
also the HMAC versions \fIof\fP those functions. It can output in traditional format (same as md5sum and shasum and the like) or it's own format.
.PP
Hashes can be output in octal, decimal, hexadecimal, uppercase hexadecimal or base64.
.PP
Hashrat also supports directory recursion, hashing entire devices, and generating a \fIhash\fP for an entire directory. It has a CGI mode that can
be used as a web-page \fIto\fP lookup \fIhashes\fP.
.SH OPTIONS
.TP
.B
-?, \fB-help\fP, \fB--help\fP
Print this help.
.TP
.B
\fB-version\fP, \fB--version\fP
Print program version.
.TP
.B
\fB-md5\fP
Use md5 \fIhash\fP algorithm. This is the default \fIhash\fP.
.TP
.B
\fB-sha1\fP
Use sha1 \fIhash\fP algorithm.
.TP
.B
\fB-sha256\fP
Use sha256 \fIhash\fP algorithm.
.TP
.B
\fB-sha512\fP
Use sha512 \fIhash\fP algorithm.
.TP
.B
\fB-whirl\fP
Use whirlpool \fIhash\fP algorithm.
.TP
.B
\fB-whirlpool\fP
Use whirlpool \fIhash\fP algorithm.
.TP
.B
\fB-jh224\fP
Use jh-224 \fIhash\fP algorithm.
.TP
.B
\fB-jh256\fP
Use jh-256 \fIhash\fP algorithm.
.TP
.B
\fB-jh384\fP
Use jh-384 \fIhash\fP algorithm.
.TP
.B
\fB-jh512\fP
Use jh-512 \fIhash\fP algorithm.
.TP
.B
\fB-hmac\fP
HMAC using specified \fIhash\fP algorithm.
.TP
.B
\fB-8\fP
Encode with octal instead \fIof\fP hex.
.TP
.B
\fB-10\fP
Encode with decimal instead \fIof\fP hex.
.TP
.B
\fB-H\fP, \fB-HEX\fP
Encode with UPPERCASE hexadecimal.
.TP
.B
\fB-64\fP, \fB-base64\fP
Encode with base64. 
.TP
.B
\fB-i64\fP, \fB-i64\fP
Encode with base64, with rearranged characters.
.TP
.B
\fB-p64\fP, \fB-p64\fP
Encode with base64 with a-z,A-Z and _-, for best compatibility with 'allowed characters' in websites.
.TP
.B
\fB-x64\fP, \fB-x64\fP
Encode with XXencode style base64.
.TP
.B
\fB-u64\fP, \fB-u64\fP
Encode with UUencode style base64.
.TP
.B
\fB-g64\fP, \fB-g64\fP
Encode with GEDCOM style base64.
.TP
.B
\fB-a85\fP, \fB-a85\fP
Encode with ASCII85.
.TP
.B
\fB-z85\fP, \fB-z85\fP
Encode with ZEROMQ variant of ASCII85.
\fB-t\fP, \fB-trad\fP
Output \fIhashes\fP in traditional md5sum, shaXsum format.
.TP
.B
\fB-tag\fP, \fB--tag\fP \fB-bsd\fP
Output \fIhashes\fP in bsdsum format.
.TP
.B
\fB-r\fP
Recurse into directories when hashing files.
.TP
.B
\fB-f\fP <listfile>
Hash files listed in <listfile>.
.TP
.B
\fB-i\fP <pattern>
Only \fIhash\fP items matching <pattern>.
.TP
.B
\fB-x\fP <pattern>
Exclude items matching <pattern>.
.TP
.B
\fB-n\fP <length>
Truncate \fIhashes\fP \fIto\fP <length> bytes.
.TP
.B
\fB-c\fP
CHECK \fIhashes\fP against list from \fIfile\fP (or stdin).
.TP
.B
\fB-cf\fP
CHECK \fIhashes\fP but only show failures.
.TP
.B
\fB-C <dir>\fP
CHECK \fIfiles\fP under dir recursively against a list from \fIfile\fP (or stdin). This can detect 'new' files
.TP
.B
\fB-Cf <dir>\fP
CHECK \fIfiles\fP under dir recursively against a list from \fIfile\fP (or stdin). This can detect 'new' files. Only show failures.
.TP
.B
\fB-m\fP
MATCH files from a list read from stdin.
.TP
.B
\fB-lm\fP
Read \fIhashes\fP from stdin, upload them \fIto\fP a memcached server (requires the \fB-memcached\fP option).
.TP
.B
\fB-X\fP, \fB-exec\fP
In CHECK or MATCH mode only examine executable files.
.TP
.B
\fB-dups\fP
Search for duplicate files.
.TP
.B
\fB-memcached\fP <server>, \fB-mcd\fP <server>
Specify memcached server. This option overrides reading list from stdin if used with \fB-m\fP, \fB-c\fP or \fB-cf\fP.
.TP
.B
\fB-h\fP <script>
Script \fIto\fP run when a \fIfile\fP fails CHECK mode, or is found in MATCH mode.
.TP
.B
\fB-hook\fP <script>
Script \fIto\fP run when a \fIfile\fP fails CHECK mode, or is found in FIND mode
.TP
.B
\fB-color\fP
Use ANSI color codes on output when checking \fIhashes\fP.
.TP
.B
\fB-S\fP, \fB-strict\fP
Strict mode: when checking, check \fIfile\fP mtime, owner, group, and inode as well as it's \fIhash\fP.
.TP
.B
\fB-d\fP
Dereference (follow) symlinks.
.TP
.B
\fB-fs\fP
Stay one filesystem.
.TP
.B
\fB-dirmode\fP
DirMode: read all files in directory and create one \fIhash\fP for them.
.TP
.B
\fB-devmode\fP
DevMode: read from a \fIfile\fP EVEN OF IT'S A DEVNODE.
.TP
.B
\fB-lines\fP
Read lines from stdin and \fIhash\fP each line independantly.
.TP
.B
\fB-rl\fP, \fB-rawlines\fP
Read lines from stdin and \fIhash\fP each line independantly, INCLUDING any trailing whitespace. This is compatible with 'echo text | md5sum'.
.TP
.B
\fB-cgi\fP
Run in HTTP CGI mode.
.TP
.B
\fB-net\fP
Treat '\fIfile\fP' arguments as either ssh or http URLs, and pull files over the network and then \fIhash\fP them (allows hashing \fIof\fP files on remote machines).
URLs are in the format ssh://[username]:[password]@[host]:[port] or http://[username]:[password]@[host]:[port].
.TP
.B
\fB-idfile\fP <path>
Path \fIto\fP a ssh private key \fIfile\fP \fIto\fP use \fIto\fP authenticate INSTEAD OF A PASSWORD when pulling files via ssh.
.TP
.B
\fB-xattr\fP
Use eXtended \fIfile\fP ATTRibutes. In \fIhash\fP mode, store \fIhashes\fP in the \fIfile\fP attributes. In check mode compare against \fIhashes\fP stored in \fIfile\fP attributes.
.TP
.B
\fB-txattr\fP
Use TRUSTED eXtended \fIfile\fP ATTRibutes. In \fIhash\fP mode, store \fIhashes\fP in trusted \fIfile\fP attributes. The trusted attributes can only be read and written by root. Under FreeBSD this means 'SYSTEM' attributes.
.TP
.B
\fB-cache\fP
Use \fIhashes\fP stored in user xattr if they're younger than the mtime \fIof\fP the \fIfile\fP. This speeds up outputting \fIhashes\fP.
.TP
.B
\fB-u\fP <types>
Update. In checking mode, update \fIhashes\fP for the files as you go. The <types> is a comma-separated list \fIof\fP things \fIto\fP update, which can be xattr memcached
or a \fIfile\fP name. This will update these targets with the \fIhash\fP that was found at the time \fIof\fP checking.
.TP
.B
\fB-hide\fP-\fIinput\fP
When reading data from stdin in linemode, set the terminal \fIto\fP not echo characters, thus hiding typed \fIinput\fP.
.TP
.B
\fB-xsel\fP
Update X11 clipboard and primary selections to the current hash. This works using Xterm command sequences. The xterm resource 'allowWindowOps' must be set to 'true' for this to work.
.TP
.B
\fB-star\fP-\fIinput\fP
When reading data from stdin in linemode replace characters with stars.
.SH NOTES
Hashrat can also detect if it's being run under any \fIof\fP the following names (e.g., via symlinks):
.TP
.B
md5sum
Run with '\fB-trad\fP \fB-md5\fP'.
.TP
.B
shasum
Run with '\fB-trad\fP \fB-sha1\fP'.
.TP
.B
sha1sum
Run with '\fB-trad\fP \fB-sha1\fP'.
.TP
.B
sha256sum
Run with '\fB-trad\fP \fB-sha256\fP'.
.TP
.B
sha512sum
Run with '\fB-trad\fP \fB-sha512\fP'.
.TP
.B
jh224sum
Run with '\fB-trad\fP \fB-jh224\fP'.
.TP
.B
jh256sum
Run with '\fB-trad\fP \fB-jh256\fP'.
.TP
.B
jh384sum
Run with '\fB-trad\fP \fB-jh384\fP'.
.TP
.B
jh512sum
Run with '\fB-trad\fP \fB-jh512\fP'.
.TP
.B
whirlpoolsum
Run with '\fB-trad\fP \fB-whirl\fP'.
.TP
.B
hashrat.cgi
Run in web-enabled 'cgi mode'.
.SH EXAMPLES
.TP
.B
\fBhashrat\fP
Generate a md5 \fIhash\fP \fIof\fP data read from stdin  (default \fIhash\fP type is md5).
.TP
.B
\fBhashrat\fP \fB-jh256\fP
Generate a jh-256 \fIhash\fP \fIof\fP data read from stdin.
.TP
.B
\fBhashrat\fP \fB-sha256\fP \fB-64\fP
Generate a sha-256 \fIhash\fP \fIof\fP data read from stdin, output with base64 encoding.
.TP
.B
\fBhashrat\fP \fB-sha256\fP \fB-64\fP \fB-lines\fP
Read lines from stdin, and generate a sha-256 with base64 encoding FOR EVERY LINE. This strips any whitespace
from the end \fIof\fP the line (including \\r and/or \\n line terminators).
.TP
.B
\fBhashrat\fP \fB-md5\fP \fB-trad\fP \fB-rawlines\fP
Read lines from stdin, and generate a md5 \fIhash\fP in traditional format for every line INCLUDING TRAILING WHITESPACE.
This is compatible with 'echo text | md5sum', where text is one line, as echo adds a newline \fIto\fP the end \fIof\fP the
text it outputs.
.TP
.B
\fBhashrat\fP *
Generate a list \fIof\fP \fIhashes\fP for files in the current directory (default \fIhash\fP type is md5).
.TP
.B
\fBhashrat\fP \fB-r\fP \fB-sha1\fP * > hashes.sha1
Generate a list \fIof\fP \fIhashes\fP for files in the current directory, AND ALL SUBDIRECTORIES, using sha1 hashing.
.TP
.B
cat hashes.sha1 > \fBhashrat\fP \fB-c\fP
Check \fIhashes\fP listed in hashes.sha1.
.TP
.B
cat hashes.sha1 > \fBhashrat\fP \fB-c\fP \fB-strict\fP
Check \fIhashes\fP listed in hashes.sha1. If \fIhashes\fP are NOT in traditional format than the \fB-strict\fP flag will cause
\fBhashrat\fP \fIto\fP check the files uid, gid, size, mtime and inode and print a failure message if any \fIof\fP those don't match.
.TP
.B
cat hashes.sha1 > \fBhashrat\fP \fB-cf\fP
Check \fIhashes\fP listed in hashes.sha1 but only output failures.
.TP
.B
cat APT1.md5 | \fBhashrat\fP \fB-m\fP \fB-r\fP /
Read a list \fIof\fP \fIhashes\fP from stdin and search recursively for files matching them.
.TP
.B
cat APT1.md5 | \fBhashrat\fP \fB-lm\fP \fB-memcached\fP 127.0.0.1
Read a list \fIof\fP \fIhashes\fP from stdin, and register them in a memcached server.
.TP
.B
\fBhashrat\fP \fB-m\fP \fB-memcached\fP 127.0.0.1 \fB-r\fP /
Search recursively for files whose \fIhashes\fP are stored in a memcached server.
.TP
.B
\fBhashrat\fP \fB-devmode\fP \fB-whirlpool\fP \fB-64\fP /dev/sda1
Generate a whirlpool \fIhash\fP \fIof\fP the entire device /dev/sda1. Output result in base 64.
.TP
.B
\fBhashrat\fP \fB-sha1\fP \fB-net\fP ssh:user:password@myhost/bin/*
Generate sha1 \fIhashes\fP \fIof\fP files in /bin/* on the remote machine 'myhost'.
.TP
.B
\fBhashrat\fP \fB-whirlpool\fP \fB-net\fP http://myhost.com/webpage.html
Generate whirlpool \fIhash\fP for the listed URL. Note, many webpages have dynamic content that changes
every time, so this will only return the same \fIhash\fP over and over if the page is static and doesn't change.
.TP
.B
\fBhashrat\fP \fB-dups\fP \fB-r\fP /home \fB-u\fP xattr
Search for duplicate files under /home. Update \fIhashes\fP stored in filesystem attributes as you go.
.SH USES FOR HASHRAT
.IP 1) 4
Strong Passwords
.PP
Hashrat can be used \fIto\fP generate strong passwords for websites. So, you don't have \fIto\fP remember the strong password, if it be always regenerate with \fBhashrat\fP.
You need \fIto\fP remember a handful \fIof\fP moderately decent passwords, i.e., things that I can't find by grepping in the '10,000 most popular passwords' list[1],
and an additional personal pin. Now, you need \fIto\fP combine the website name, one \fIof\fP passwords, and the personal pin, into a string and feed them into \fBhashrat\fP:
.PP
.nf
.fam C
    $ echo "facebook.com password 1234" | hashrat \-sha1 \-64

.fam T
.fi
Obviously, a good password isn't 'password' and a good pin isn't '1234', but you get the idea. This gives a 28-character string that should take "8.02 trillion
centuries" \fIto\fP crack with a "massive cracking array", according \fIto\fP Steve Gibson's Password haystacks utility[2]. This is what I then use as my password. Unfortunately
some websites won't take a 28-character password, and for these you can truncate \fIto\fP the appropriate length (using the \fB-n\fP flag), but the results are still stronger
than anything you could remember, and nothing needs storing on disk (as with password managers).
.PP
There are some dangers \fIto\fP using the 'echo' method shown above if you are on a shared machine, or if someone gets hold \fIof\fP your computer/harddrive. On a shared machine
someone could type 'ps ax' \fIto\fP see all commands running, and if they time it right, they might see your command-line with your password in it. Another danger lies in
using a shell (like bash) that will record your typed commands so you can recall them later. Bash stores this information on disk in the \fIfile\fP .bash_history, so if
you use the 'echo' method shown above your password will be saved on disk. To combat this \fBhashrat\fP has line mode:
.PP
.nf
.fam C
    $ hashrat \-sha1 \-64 \-lines

.fam T
.fi
This reads lines from stdin, so type into \fBhashrat\fP and then press ENTER, and you'll be given the \fIhash\fP \fIof\fP the line you typed. By this method your password is neither
visible in 'ps ax', nor is ever stored on disk.
.PP
A \fB-lines\fP will produce a different \fIhash\fP \fIto\fP the 'echo' method listed above, because it strips any trailing whiespace off the lines read. If you want strict compatiblity
with 'echo' (by default echo adds a newline \fIto\fP the end \fIof\fP the text \fIto\fP output) then use rawlines mode:
.PP
.nf
.fam C
    $ hashrat \-sha1 \-64 \-rawlines

.fam T
.fi
Finally, you can prevent shoulder-surfers seeing you type your password by using the \fB-hide\fP-\fIinput\fP or \fB-star\fP-\fIinput\fP \fIoptions\fP \fIto\fP hide what you type.
.PP
.nf
.fam C
    [1] https://github.com/discourse/discourse/blob/master/lib/common_passwords/10k-common-passwords.txt

    [2] https://www.grc.com/haystack.htm

.fam T
.fi
.IP 2) 4
Watching for \fIfile\fP changes
.PP
Like md5sum/shasum etc, \fBhashrat\fP can be used \fIto\fP detect changes in files that might indicate malicious activity. For instance, in order \fIto\fP get early warning \fIof\fP malware
like cryptolocker (that encrypts files on a users disk, or on network shares, and then demands a ransom for \fIfile\fP recovery) you can scatter about the disk a number
\fIof\fP Canary files that should not change. You need record their \fIhashes\fP and regularly check them. If they change, you will know something is going on.
.PP
Hashes generated by \fBhashrat\fP can be output \fIto\fP a \fIfile\fP, or stored in extended \fIfile\fP attributes, or in a memcached server.
.PP
.nf
.fam C
    $ hashrat \-sha256 \-r . > /tmp/files.sha256

    $ hashrat \-sha256 \-r . \-xattr

    $ hashrat \-sha256 \-r . \-memcached

.fam T
.fi
Similarly these can then be used \fIto\fP check files later:
.PP
.nf
.fam C
    $ cat /tmp/files.sha256 | hashrat -c \-sha256

    $ hashrat \-C . \-sha256  \-xattr

    $ hashrat \-C /tmp \-sha256  \-memcached

.fam T
.fi
Note that -c checks only check the files in the supplied list. The -C flag instead checks all files in a directory (supplied on command line) and expects to find those in the list. This means that -C can find new files that aren't in the list, whereas -c can't.
.fi
There is a slight difference between xattr/memcached checks and checks where a list is read from stdin. Currently when reading from stdin \fBhashrat\fP will ONLY check the
files in the list. However, in \fB-xattr\fP and \fB-memcached\fP mode, it will check all files, outputting and error for those where no stored \fIhash\fP can be found. This is likely
\fIto\fP change in the a future release, with the stdin method being brought into line with the others.
.IP 3) 4
Finding files that match \fIhashes\fP
.PP
Using the \fB-m\fP flag \fBhashrat\fP can be told \fIto\fP read a range \fIof\fP \fIhashes\fP from stdin, and then search for files matching those \fIhashes\fP. For Example:
.PP
.nf
.fam C
    $ cat APT1-AppendixE-MD5s.txt | hashrat \-r \-m /usr

.fam T
.fi
The last command will search recursively under /usr for files with \fIhashes\fP matching those in APT1-AppendixE-MD5s.txt. The \fIinput\fP on stdin must begin with a \fIhash\fP, anything
written after the \fIhash\fP will be treated as a comment \fIto\fP be displayed if a \fIfile\fP matching the \fIhash\fP is found.
.PP
Hashtypes other than md5 can be used thusly:
.PP
.nf
.fam C
    $ cat sha1-list.lst | hashrat \-r \-sha1 \-m /usr

.fam T
.fi
Hashes can also be loaded into a memcached server, so that the same \fIfile\fP list can be checked on a number \fIof\fP machines, without needing \fIto\fP store the hashlist on those
machines. First you need load the \fIhashes\fP:
.PP
.nf
.fam C
    $ cat APT1-AppendixE-MD5s.txt | hashrat \-lm \-memcached 192.168.1.5

.fam T
.fi
The last line loads the \fIhashes\fP \fIto\fP a memcached server at 192.168.1.5. You can then search against the memcached server by:
.PP
.nf
.fam C
    $ hashrat \-r \-m \-memcached 192.168.1.5 /usr

.fam T
.fi
.IP 4) 4
Find duplicate files
.PP
Using the \fB-dups\fP flag (usually in combination with the \fB-r\fP recursive flag) \fBhashrat\fP can be set \fIto\fP search for duplicate files and output any found \fIto\fP stdout.
.IP 5) 4
CGI Mode
.PP
If \fBhashrat\fP is run with the \fB-cgi\fP flag, or if it's run with a name \fIof\fP hashrat.cgi (either by renaming the \fBhashrat\fP executable, or via a symbolic link) it will output a
webpage that allows users \fIto\fP look up \fIhashes\fP over the web. This allows \fIto\fP look-up your strong passwords even if youI don't have access \fIto\fP a local version \fIof\fP \fBhashrat\fP.
.SH EXTENDED FILESYSTEM ATTRIBUTES

Hashrat can use extended filesystem attributes where these are supported. This allows a \fIhash\fP \fIto\fP be stored in the filesystem metadata \fIof\fP the target \fIfile\fP. This can
then be used for checking \fIhashes\fP, or for caching \fIhashes\fP \fIto\fP produce faster output during hashing runs. There are two types \fIof\fP filesystem attribute, trusted attributes,
which can only be set and read by root, and user attributes, which can be set and read by any user that has the appropriate permissions for the \fIfile\fP.
.PP
Hashes can be stored against files by using the \fB-xattr\fP option \fIto\fP set user attributes:
.PP
.nf
.fam C
    $ hashrat \-sha256 \-r . \-xattr

.fam T
.fi
And using the \fB-txattr\fP flag \fIto\fP set trusted attributes (you must be root \fIto\fP set trusted attributes):
.PP
.nf
.fam C
    # hashrat \-sha256 \-r . \-txattr

.fam T
.fi
When checking either flag can be used, but \fBhashrat\fP will always use trusted attributes when running as root, if those are avaialable, otherwise it will fall
back \fIto\fP user attributes.
.PP
.nf
.fam C
    $ hashrat \-c \-sha256 \-r . \-xattr

.fam T
.fi
The \fB-cache\fP option allows using stored \fIhashes\fP rather than regenerating \fIhashes\fP. It only considers \fIhashes\fP stored in user attributes at current.
.PP
.nf
.fam C
    $ hashrat \-r . \-cache

.fam T
.fi
This makes getting a report \fIof\fP \fIhashes\fP considerably faster, but it runs the risk that the \fIhashes\fP may not be accurate. Hashrat will only output a \fIhash\fP stored in \fIfile\fP
attributes if the storage time \fIof\fP the \fIhash\fP is younger than the modify time (mtime) \fIof\fP the \fIfile\fP, however, this means an attacker could change the modify time \fIof\fP the \fIfile\fP
\fIto\fP hide changes they've made. Thus this feature should not be used for security checking purposes (but should be safe for uses like finding files that have changed and
need \fIto\fP be backed up, for instance).
.SH AUTHOR
The \fBhashrat\fP was written by Colum Paget <colums.projects@gmail.com>.
.PP
This manual page was written by Joao Eriberto Mota Filho <eriberto@debian.org>
for the Debian project (but may be used by others).
