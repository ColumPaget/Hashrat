.TH hashrat "1" "Jan 2015" "HASHRAT 1.19" "hashing tool supporting several hashes and recursivity"
.\"Text automatically generated by txt2man
.SH NAME
\fBhashrat \fP- hashing tool supporting several hashes and recursivity
\fB
.SH SYNOPSIS
.nf
.fam C
\fBhashrat\fP [\fIoptions\fP] [\fIpaths\fP to \fIhash\fP]

\fBhashrat\fP \fB-c\fP [\fIoptions\fP] [\fIinput\fP \fIfile\fP of \fIhashes\fP]

.fam T
.fi
.SH DESCRIPTION
Hashrat is a \fIhash\fP-generation utility that supports the md5, sha1, sha256, sha512, whirlpool, jh-224, jh256, jh-384 and jh-512 \fIhash\fP functions, and
also the HMAC versions of those functions. It can output in traditional format (same as md5sum and shasum and the like) or it's own format.
.PP
Hashes can be output in octal, decimal, hexadecimal, uppercase hexadecimal and various types of base32 and base64.
.PP
Hashrat also supports directory recursion, hashing entire devices, and generating a \fIhash\fP for an entire directory. It has a CGI mode that can
be used as a web-page to lookup \fIhashes\fP.
.SH OPTIONS
.TP
.B
-?, \fB-help\fP, \fB--help\fP
Print this help.
.TP
.B
\fB-version\fP, \fB--version\fP
Print program version.
.TP
.B
\fB-type <type>\fP
Use \fIhash\fP algorithm <type>. Hash types can be chained as a comma-seperated list.
.TP
.B
\fB-md5\fP
Use md5 \fIhash\fP algorithm. This is the default \fIhash\fP.
.TP
.B
\fB-sha1\fP
Use sha1 \fIhash\fP algorithm.
.TP
.B
\fB-sha256\fP
Use sha256 \fIhash\fP algorithm.
.TP
.B
\fB-sha512\fP
Use sha512 \fIhash\fP algorithm.
.TP
.B
\fB-whirl\fP
Use whirlpool \fIhash\fP algorithm.
.TP
.B
\fB-whirlpool\fP
Use whirlpool \fIhash\fP algorithm.
.TP
.B
\fB-jh224\fP
Use jh-224 \fIhash\fP algorithm.
.TP
.B
\fB-jh256\fP
Use jh-256 \fIhash\fP algorithm.
.TP
.B
\fB-jh384\fP
Use jh-384 \fIhash\fP algorithm.
.TP
.B
\fB-jh512\fP
Use jh-512 \fIhash\fP algorithm.
.TP
.B
\fB-hmac\fP
HMAC using specified \fIhash\fP algorithm.
.TP
.B
\fB-totp <secret>\fP
TOTP code from supplied secret (defaults to google authenticator compatible code).
.TP
.B
\fB-totp <url>\fP
TOTP code from supplied otpauth url, the url is distinguished from a secret using the leading 'oftpauth:' component.
.TP
.B
\fB-digits <n>\fP
Produce TOTP code with <n> digits.
.TP
.B
\fB-period <n>\fP
Produce TOTP code with period/lifetime of <n> seconds.
.TP
.B
\fB-8\fP
Encode with octal instead of hex.
.TP
.B
\fB-10\fP
Encode with decimal instead of hex.
.TP
.B
\fB-H\fP, \fB-HEX\fP
Encode with UPPERCASE hexadecimal.
.TP
.B
\fb-32\fp, \fb-base32\fp
encode with base32. 
.TP
.B
\fb-c32\fp
encode with Crockfords base32. 
.TP
.B
\fb-w32\fp
encode with word-safe base32. 
.TP
.B
\fb-z32\fp
encode with zbase32. 
.TP
.B
\fb-64\fp, \fb-base64\fp
encode with base64. 
.TP
.B
\fB-i64\fP, \fB-i64\fP
Encode with base64, with rearranged characters.
.TP
.B
\fB-p64\fP, \fB-p64\fP
Encode with base64 with a-z,A-Z and _-, for best compatibility with 'allowed characters' in websites.
.TP
.B
\fB-x64\fP, \fB-x64\fP
Encode with XXencode style base64.
.TP
.B
\fB-u64\fP, \fB-u64\fP
Encode with UUencode style base64.
.TP
.B
\fB-g64\fP, \fB-g64\fP
Encode with GEDCOM style base64.
.TP
.B
\fB-a85\fP, \fB-a85\fP
Encode with ASCII85.
.TP
.B
\fB-z85\fP, \fB-z85\fP
Encode with ZEROMQ variant of ASCII85.
\fB-t\fP, \fB-trad\fP
Output \fIhashes\fP in traditional md5sum, shaXsum format.
.TP
.B
\fB-tag\fP, \fB--tag\fP \fB-bsd\fP
Output \fIhashes\fP in bsdsum format.
.TP
.B
\fB-r\fP
Recurse into directories when hashing files.
.TP
.B
\fB-hid\fP
Show hidden (starting with .) files
.TP
.B
\fB-hidden\fP
Show hidden (starting with .) files
.TP
.B
\fB-f\fP <listfile>
Hash files listed in <listfile>.
.TP
.B
\fB-i\fP <pattern>
Only \fIhash\fP items matching a comma-seperated list of shell patterns. Please be aware that -i does not yet work on directories, only files.
.TP
.B
\fB-x\fP <pattern>
Exclude items matching a comma-seperated list of shell patterns. Works on both directories and files.
.TP
.B
\fB-X\fP <path>
Exclude items listed in file <path>. Items in the file can be wildcards.
.TP
.B
\fB -name\fP  <pattern> 
Only hash items matching a comma-seperated list of shell patterns (-name as in the 'find' command).
.TP
.B
\fB -mtime\fP  <days> 
Only hash items <days> old. Has the same format as the find command, e.g. -10 is younger than ten days, +10 is older than ten, and 10 is ten days old.
.TP
.B
\fB -mmin\fP  <mins> 
Only hash items <min> minutes old. Has the same format as the find command, e.g. -10 is younger than ten mins, +10 is older than ten, and 10 is ten mins old.
.TP
.B
\fB -myear\fP  <years> 
Only hash items <years> old. Has the same format as the find command, e.g. -10 is younger than ten years, +10 is older than ten, and 10 is ten years old.
.TP
.B
\fB-exec\fP
In CHECK or MATCH mode only examine executable files.
.TP
.B
\fB-dups\fP
Search for duplicate files.
.TP
.B
\fB-n\fP <length>
Truncate \fIhashes\fP to <length> bytes.
.TP
.B
\fB-c\fP
CHECK \fIhashes\fP against list from \fIfile\fP (or stdin).
.TP
.B
\fB-cf\fP
CHECK \fIhashes\fP but only show failures.
.TP
.B
\fB-C <dir>\fP
CHECK \fIfiles\fP under dir recursively against a list from \fIfile\fP (or stdin). This can detect 'new' files
.TP
.B
\fB-Cf <dir>\fP
CHECK \fIfiles\fP under dir recursively against a list from \fIfile\fP (or stdin). This can detect 'new' files. Only show failures.
.TP
.B
\fB-m\fP
MATCH files from a list read from stdin.
.TP
.B
\fB-lm\fP
Read \fIhashes\fP from stdin, upload them to a memcached server (requires the \fB-memcached\fP option).
.TP
.B
\fB-memcached\fP <server>, \fB-mcd\fP <server>
Specify memcached server. This option overrides reading list from stdin if used with \fB-m\fP, \fB-c\fP or \fB-cf\fP.
.TP
.B
\fB-h\fP <script>
\fB-hook\fP <script>
Script to run when a \fIfile\fP fails CHECK mode, or is found in MATCH mode. Script is passed the filename as an argument. In 'find duplicates' mode a second file name (the duplicate) will be passed as the second argument.
.TP
.B
\fB-color\fP
Use ANSI color codes on output when checking \fIhashes\fP.
.TP
.B
\fB-S\fP, \fB-strict\fP
Strict mode: when checking, check \fIfile\fP mtime, owner, group, and inode as well as it's \fIhash\fP.
.TP
.B
\fB-d\fP
Dereference (follow) symlinks.
.TP
.B
\fB-fs\fP
Stay one filesystem.
.TP
.B
\fB-dir\fP
\fB-dirmode\fP
DirMode: read all files in directory and create one \fIhash\fP for them (implies -r).
.TP
.B
\fB-devmode\fP
DevMode: read from a \fIfile\fP EVEN OF IT'S A DEVNODE.
.TP
.B
\fB-lines\fP
Read lines from stdin and \fIhash\fP each line independantly.
.TP
.B
\fB-rl\fP, \fB-rawlines\fP
Read lines from stdin and \fIhash\fP each line independantly, INCLUDING any trailing whitespace. This is compatible with 'echo text | md5sum'.
.TP
.B
\fB-cgi\fP
Run in HTTP CGI mode.
.TP
.B
\fB-xdialog\fP
Run in 'xdialog' (zenity, yad or qarama) mode.
.TP
.B
\fB-dialog-types\fP
Specify a list of dialog commands and use the first found on the system. Default is 'yad,zenity,qarma'. 
.TP
.B
\fB-iprefix\fP <prefix>
String to prefix all input before hashing
.TP
.B
\fB-oprefix\fP <prefix>
Prefix to add to the front of output hashes
.TP
.B
\fB-net\fP
Treat '\fIfile\fP' arguments as either ssh or http URLs, and pull files over the network and then \fIhash\fP them (allows hashing of files on remote machines).
URLs are in the format ssh://[username]:[password]@[host]:[port] or http://[username]:[password]@[host]:[port].
.TP
.B
\fB-idfile\fP <path>
Path to a ssh private key \fIfile\fP to use to authenticate INSTEAD OF A PASSWORD when pulling files via ssh.
.TP
.B
\fB-xattr\fP
Use eXtended \fIfile\fP ATTRibutes. In \fIhash\fP mode, store \fIhashes\fP in the \fIfile\fP attributes. In check mode compare against \fIhashes\fP stored in \fIfile\fP attributes.
.TP
.B
\fB-txattr\fP
Use TRUSTED eXtended \fIfile\fP ATTRibutes. In \fIhash\fP mode, store \fIhashes\fP in trusted \fIfile\fP attributes. The trusted attributes can only be read and written by root. Under FreeBSD this means 'SYSTEM' attributes.
.TP
.B
\fB-cache\fP
Use \fIhashes\fP stored in user xattr if they're younger than the mtime of the \fIfile\fP. This speeds up outputting \fIhashes\fP. When storing xattr hashes, do not update files that already have the correct hash.
.TP
.B
\fB-u\fP <types>
Update. In checking mode, update \fIhashes\fP for the files as you go. The <types> is a comma-separated list of things to update, which can be xattr memcached
or a \fIfile\fP name. This will update these targets with the \fIhash\fP that was found at the time of checking.
.TP
.B
\fB-hide\fP-\fIinput\fP
When reading data from stdin in linemode, set the terminal to not echo characters, thus hiding typed \fIinput\fP.
.TP
.B
\fB-xsel\fP
Update X11 clipboard and primary selections to the current hash. This works using Xterm command sequences. The xterm resource 'allowWindowOps' must be set to 'true' for this to work.
.TP
.B
\fB-star\fP-\fIinput\fP
When reading data from stdin in linemode replace characters with stars.
.SH NOTES
Hashrat can also detect if it's being run under any of the following names (e.g., via symlinks):
.TP
.B
md5sum
Run with '\fB-trad\fP \fB-md5\fP'.
.TP
.B
shasum
Run with '\fB-trad\fP \fB-sha1\fP'.
.TP
.B
sha1sum
Run with '\fB-trad\fP \fB-sha1\fP'.
.TP
.B
sha256sum
Run with '\fB-trad\fP \fB-sha256\fP'.
.TP
.B
sha512sum
Run with '\fB-trad\fP \fB-sha512\fP'.
.TP
.B
jh224sum
Run with '\fB-trad\fP \fB-jh224\fP'.
.TP
.B
jh256sum
Run with '\fB-trad\fP \fB-jh256\fP'.
.TP
.B
jh384sum
Run with '\fB-trad\fP \fB-jh384\fP'.
.TP
.B
jh512sum
Run with '\fB-trad\fP \fB-jh512\fP'.
.TP
.B
whirlpoolsum
Run with '\fB-trad\fP \fB-whirl\fP'.
.TP
.B
hashrat.cgi
Run in web-enabled 'cgi mode'.
.SH EXAMPLES
.TP
.B
\fBhashrat\fP
Generate a md5 \fIhash\fP of data read from stdin  (default \fIhash\fP type is md5).
.TP
.B
\fBhashrat\fP \fB-jh256\fP
Generate a jh-256 \fIhash\fP of data read from stdin.
.TP
.B
\fBhashrat\fP \fB-sha256\fP \fB-64\fP
Generate a sha-256 \fIhash\fP of data read from stdin, output with base64 encoding.
.TP
.B
\fBhashrat\fP \fB-sha256\fP \fB-64\fP \fB-lines\fP
Read lines from stdin, and generate a sha-256 with base64 encoding FOR EVERY LINE. This strips any whitespace
from the end of the line (including \\r and/or \\n line terminators).
.TP
.B
\fBhashrat\fP \fB-md5\fP \fB-trad\fP \fB-rawlines\fP
Read lines from stdin, and generate a md5 \fIhash\fP in traditional format for every line INCLUDING TRAILING WHITESPACE.
This is compatible with 'echo text | md5sum', where text is one line, as echo adds a newline to the end of the
text it outputs.
.TP
.B
\fBhashrat\fP \fB-type sha256,whirl,md5\fP \fB-64\fP
Generate a sha-256 \fIhash\fP of data read from stdin, then hash the result with whirlpool, then with md5.
.TP
.B
\fBhashrat\fP *
Generate a list of \fIhashes\fP for files in the current directory (default \fIhash\fP type is md5).
.TP
.B
\fBhashrat\fP \fB-r\fP \fB-sha1\fP * > hashes.sha1
Generate a list of \fIhashes\fP for files in the current directory, AND ALL SUBDIRECTORIES, using sha1 hashing.
.TP
.B
cat hashes.sha1 | \fBhashrat\fP \fB-c\fP
Check \fIhashes\fP listed in hashes.sha1.
.TP
.B
cat hashes.sha1 | \fBhashrat\fP \fB-c\fP \fB-strict\fP
Check \fIhashes\fP listed in hashes.sha1. If \fIhashes\fP are NOT in traditional format than the \fB-strict\fP flag will cause
\fBhashrat\fP to check the files uid, gid, size, mtime and inode and print a failure message if any of those don't match.
.TP
.B
cat hashes.sha1 | \fBhashrat\fP \fB-cf\fP
Check \fIhashes\fP listed in hashes.sha1 but only output failures.
.TP
.B
cat APT1.md5 | \fBhashrat\fP \fB-m\fP \fB-r\fP /
Read a list of \fIhashes\fP from stdin and search recursively for files matching them.
.TP
.B
cat APT1.md5 | \fBhashrat\fP \fB-lm\fP \fB-memcached\fP 127.0.0.1
Read a list of \fIhashes\fP from stdin, and register them in a memcached server.
.TP
.B
\fBhashrat\fP \fB-m\fP \fB-memcached\fP 127.0.0.1 \fB-r\fP /
Search recursively for files whose \fIhashes\fP are stored in a memcached server.
.TP
.B
\fBhashrat\fP \fB-devmode\fP \fB-whirlpool\fP \fB-64\fP /dev/sda1
Generate a whirlpool \fIhash\fP of the entire device /dev/sda1. Output result in base 64.
.TP
.B
\fBhashrat\fP \fB-sha1\fP \fB-net\fP ssh:user:password@myhost/bin/*
Generate sha1 \fIhashes\fP of files in /bin/* on the remote machine 'myhost'.
.TP
.B
\fBhashrat\fP \fB-whirlpool\fP \fB-net\fP http://myhost.com/webpage.html
Generate whirlpool \fIhash\fP for the listed URL. Note, many webpages have dynamic content that changes
every time, so this will only return the same \fIhash\fP over and over if the page is static and doesn't change.
.TP
.B
\fBhashrat\fP \fB-dups\fP \fB-r\fP /home \fB-u\fP xattr
Search for duplicate files under /home. Update \fIhashes\fP stored in filesystem attributes as you go.
.SH USES FOR HASHRAT
.IP 1) 4
Strong Passwords
.PP
Hashrat can be used to generate strong passwords for websites. So, you don't have to remember the strong password, if it be always regenerate with \fBhashrat\fP.
You need to remember a handful of moderately decent passwords, i.e., things that I can't find by grepping in the '10,000 most popular passwords' list[1],
and an additional personal pin. Now, you need to combine the website name, one of passwords, and the personal pin, into a string and feed them into \fBhashrat\fP:
.PP
.nf
.fam C
    $ echo "facebook.com password 1234" | hashrat \-sha1 \-64

.fam T
.fi
Obviously, a good password isn't 'password' and a good pin isn't '1234', but you get the idea. This gives a 28-character string that should take "8.02 trillion
centuries" to crack with a "massive cracking array", according to Steve Gibson's Password haystacks utility[2]. This is what I then use as my password. Unfortunately
some websites won't take a 28-character password, and for these you can truncate to the appropriate length (using the \fB-n\fP flag), but the results are still stronger
than anything you could remember, and nothing needs storing on disk (as with password managers).
.PP
There are some dangers to using the 'echo' method shown above if you are on a shared machine, or if someone gets hold of your computer/harddrive. On a shared machine
someone could type 'ps ax' to see all commands running, and if they time it right, they might see your command-line with your password in it. Another danger lies in
using a shell (like bash) that will record your typed commands so you can recall them later. Bash stores this information on disk in the \fIfile\fP .bash_history, so if
you use the 'echo' method shown above your password will be saved on disk. To combat this \fBhashrat\fP has line mode:
.PP
.nf
.fam C
    $ hashrat \-sha1 \-64 \-lines

.fam T
.fi
This reads lines from stdin, so type into \fBhashrat\fP and then press ENTER, and you'll be given the \fIhash\fP of the line you typed. By this method your password is neither
visible in 'ps ax', nor is ever stored on disk.
.PP
A \fB-lines\fP will produce a different \fIhash\fP to the 'echo' method listed above, because it strips any trailing whiespace off the lines read. If you want strict compatiblity
with 'echo' (by default echo adds a newline to the end of the text to output) then use rawlines mode:
.PP
.nf
.fam C
    $ hashrat \-sha1 \-64 \-rawlines

.fam T
.fi
Finally, you can prevent shoulder-surfers seeing you type your password by using the \fB-hide\fP-\fIinput\fP or \fB-star\fP-\fIinput\fP \fIoptions\fP to hide what you type.
.PP
.nf
.fam C
    [1] https://github.com/discourse/discourse/blob/master/lib/common_passwords/10k-common-passwords.txt

    [2] https://www.grc.com/haystack.htm

.fam T
.fi
.IP 2) 4
Watching for \fIfile\fP changes
.PP
Like md5sum/shasum etc, \fBhashrat\fP can be used to detect changes in files that might indicate malicious activity. For instance, in order to get early warning of malware
like cryptolocker (that encrypts files on a users disk, or on network shares, and then demands a ransom for \fIfile\fP recovery) you can scatter about the disk a number
of Canary files that should not change. You need record their \fIhashes\fP and regularly check them. If they change, you will know something is going on.
.PP
Hashes generated by \fBhashrat\fP can be output to a \fIfile\fP, or stored in extended \fIfile\fP attributes, or in a memcached server.
.PP
.nf
.fam C
    $ hashrat \-sha256 \-r . > /tmp/files.sha256

    $ hashrat \-sha256 \-r . \-xattr

    $ hashrat \-sha256 \-r . \-memcached

.fam T
.fi
Similarly these can then be used to check files later:
.PP
.nf
.fam C
    $ cat /tmp/files.sha256 | hashrat -c \-sha256

    $ hashrat \-C . \-sha256  \-xattr

    $ hashrat \-C /tmp \-sha256  \-memcached

.fam T
.fi
Note that -c checks only check the files in the supplied list. The -C flag instead checks all files in a directory (supplied on command line) and expects to find those in the list. This means that -C can find new files that aren't in the list, whereas -c can't.
.fi
There is a slight difference between xattr/memcached checks and checks where a list is read from stdin. Currently when reading from stdin \fBhashrat\fP will ONLY check the
files in the list. However, in \fB-xattr\fP and \fB-memcached\fP mode, it will check all files, outputting and error for those where no stored \fIhash\fP can be found. This is likely
to change in the a future release, with the stdin method being brought into line with the others.
.IP 3) 4
Finding files that match \fIhashes\fP
.PP
Using the \fB-m\fP flag \fBhashrat\fP can be told to read a range of \fIhashes\fP from stdin, and then search for files matching those \fIhashes\fP. For Example:
.PP
.nf
.fam C
    $ cat APT1-AppendixE-MD5s.txt | hashrat \-r \-m /usr

.fam T
.fi
The last command will search recursively under /usr for files with \fIhashes\fP matching those in APT1-AppendixE-MD5s.txt. The \fIinput\fP on stdin must begin with a \fIhash\fP, anything
written after the \fIhash\fP will be treated as a comment to be displayed if a \fIfile\fP matching the \fIhash\fP is found.
.PP
Hashtypes other than md5 can be used thusly:
.PP
.nf
.fam C
    $ cat sha1-list.lst | hashrat \-r \-sha1 \-m /usr

.fam T
.fi
Hashes can also be loaded into a memcached server, so that the same \fIfile\fP list can be checked on a number of machines, without needing to store the hashlist on those
machines. First you need load the \fIhashes\fP:
.PP
.nf
.fam C
    $ cat APT1-AppendixE-MD5s.txt | hashrat \-lm \-memcached 192.168.1.5

.fam T
.fi
The last line loads the \fIhashes\fP to a memcached server at 192.168.1.5. You can then search against the memcached server by:
.PP
.nf
.fam C
    $ hashrat \-r \-m \-memcached 192.168.1.5 /usr

.fam T
.fi
.IP 4) 4
Find duplicate files
.PP
Using the \fB-dups\fP flag (usually in combination with the \fB-r\fP recursive flag) \fBhashrat\fP can be set to search for duplicate files and output any found to stdout.

.IP 5) 4
As an 'ls'
.PP
Hashrat outputs a file's name, type, mode, mtime, uid, gid and size, along with a hash. This allows it to be used as a kind of 'ls' by ftp style programs, listing all the details of a file, but with the added feature of a hash.

.IP 6) 4
Hashing files on remote machines
.PP
If run with the '-net' option, hashrat will treat paths starting with 'http://' or 'ssh://' differently, connecting to the target machine and pulling files off it (hashrat assumes there is no hashing program on the remote machine, and that it must therefore download the files to hash them). For ssh paths wildcars are supported:
.PP
.nf
.fam C
		hashrat -net ssh://username:password@server/usr/bin/*
.fam T
.fi

.IP 7) 4
As a TOTP authenticator
.PP
Hashrat can be used as a TOTP authenticator, and defaults to google-authenticator compatible codes.
.PP
.nf
.fam C
		hashrat -totp 3EK4LIB2553CUPA7DBXJMMKDCYTEA2IZA
.fam T
.fi



.SH HOOKSCRIPTS
.PP
  Hookscripts, defined using the \fB-h\fP or \fB-hook\fP command-line options, are scripts that are run for each hashed item. \fB-h\fP and \fB-hook\fP options take an argument that is the path to the script. Hookscripts behave differently in different modes:

.TP
\fBCheck Hashes\fP mode.
The hookscript is called if a file doesn't match it's expected hash, or is not listed in the expected hashes. It is passed the path of the file.
.TP
\fBLocate files\fP mode  
The hookscript is called if a file matches the hash to locate. It is passed the path of the file.
.TP
\fBFind duplicates\fP mode
The hookscript is called if a file is a duplicate of another file. It is passed the paths of both files.

.SH CGI Mode
.PP
If \fBhashrat\fP is run with the \fB-cgi\fP flag, or if it's run with a name of \fBhashrat.cgi\fP (either by renaming the \fBhashrat\fP executable, or via a symbolic link) it will output a webpage that allows users to look up \fIhashes\fP over the web. This allows to look-up your strong passwords even if you don't have access to a local version of \fBhashrat\fP.
.PP
CGI Mode can be configured using an options file. The file path is passed in the url, like this:
.nf
.fam C
hashrat.cgi?OptionsFile=/etc/hashrat.options
.fam T
.fi

If an options file is used, then CGI mode uses the options in the file as its defaults. The options file contains the following :
.TP
HashType <type>      Type of hash to generate
.TP
Encoding <type>      Type of encoding to use for outputted hash
.TP
Line Ending <type>   Line ending to append to input text. This is for compatability with command-line usage with "-rawlines". Options are "none", "lf", "crlf" or "cr", meaning "none", "newline", "carriage-return newline" and "carriage-return" respectively.
.TP
OutputLength <len>   Crop output hash to length len "len"
.TP
SegmentLength <len>  Break output up into segments of length "len"
.TP
SegmentChar <char>   Seperate output segments with character "char"
.TP
NoOptions            Do not offer the user the options so they can change them. Just show an entry box to enter text.
.TP
HideText             Hide inputted text (overrides any other config)
.TP
ShowText             Show inputted text (overrides any other config)
.PP
.TP
Example:
.nf
.fam C
HashType=sha256
Encoding=base64
LineEnding=none
OutputLength=12
SegmentLength=4
SegmentChar=+
NoOptions=Y
.fam T
.fi



.SH TOTP MODE

Hashrat can be used as a TOTP (Time-based One Time Password) authenticator and defaults to google-authenticator compatible codes. The simplest use case is:

.PP
.nf
.fam C
hashrat -totp <secret>
.fam T
.fi


It's possible to change the hash, period/lifetime and number of digits in the TOTP code like so:

.PP
.nf
.fam C
hashrat -totp 3EK4LIB2553CUPA7DB -sha256 -period 90 -digits 8
.fam T
.fi



.SH CLIPBOARD OUTPUT

Hashes produced in standard-in input mode and TOTP codes can be pushed to the system clipboard using the `-clip` option. This option first tries to find a command that can set the clipboard, searching for one of 'xsel', 'xclip' or 'pbcopy'. If it can't find any of these, it falls back to using xterm's built in clipboard setting method.

Alternatively the `-xsel` option only attempts to use the xterm clipboard setting method.

The default list of clipboard commands can be overridden using the `-clipcmd` option.


.SH QRCODE OUTPUT

Hashes produced in standard-in input mode and TOTP codes can be displayed as qrcodes using the `-qr` or `-qrcode` options. These options require the "qrencode" utility to be installed, and also an image viewer that can be used to display the qrcode image. 

By default hashrat searches for the following image viewers:

.PP
.nf
.fam C
imlib2_view,fim,feh,display,xv,phototonic,qimageviewer,pix,sxiv,qimgv,qview,nomacs,geeqie,ristretto,mirage,fotowall,links -g
.fam T
.fi

The default list of image viewers can be overridden using the `-viewcmd` option.



.SH EXTENDED FILESYSTEM ATTRIBUTES

Hashrat can use extended filesystem attributes where these are supported. This allows a \fIhash\fP to be stored in the filesystem metadata of the target \fIfile\fP. This can
then be used for checking \fIhashes\fP, or for caching \fIhashes\fP to produce faster output during hashing runs. There are two types of filesystem attribute, trusted attributes,
which can only be set and read by root, and user attributes, which can be set and read by any user that has the appropriate permissions for the \fIfile\fP.
.PP
Hashes can be stored against files by using the \fB-xattr\fP option to set user attributes:
.PP
.nf
.fam C
    $ hashrat \-sha256 \-r . \-xattr

.fam T
.fi
And using the \fB-txattr\fP flag to set trusted attributes (you must be root to set trusted attributes):
.PP
.nf
.fam C
    # hashrat \-sha256 \-r . \-txattr

.fam T
.fi
When checking either flag can be used, but \fBhashrat\fP will always use trusted attributes when running as root, if those are avaialable, otherwise it will fall
back to user attributes.
.PP
.nf
.fam C
    $ hashrat \-c \-sha256 \-r . \-xattr

.fam T
.fi
The \fB-cache\fP option allows using stored \fIhashes\fP rather than regenerating \fIhashes\fP. It only considers \fIhashes\fP stored in user attributes at current.
.PP
.nf
.fam C
    $ hashrat \-r . \-cache

.fam T
.fi
This makes getting a report of \fIhashes\fP considerably faster, but it runs the risk that the \fIhashes\fP may not be accurate. Hashrat will only output a \fIhash\fP stored in \fIfile\fP
attributes if the storage time of the \fIhash\fP is younger than the modify time (mtime) of the \fIfile\fP, however, this means an attacker could change the modify time of the \fIfile\fP
to hide changes they've made. Thus this feature should not be used for security checking purposes (but should be safe for uses like finding files that have changed and
need to be backed up, for instance).
.SH AUTHOR
The \fBhashrat\fP was written by Colum Paget <colums.projects@gmail.com>.
.PP
This manual page was written by Joao Eriberto Mota Filho <eriberto@debian.org>
for the Debian project (but may be used by others).
