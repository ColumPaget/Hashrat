#include "libUseful-2.0/libUseful.h"
#include "glob.h"

#define FLAG_RECURSE 1
#define FLAG_VERBOSE 2
#define FLAG_DIRMODE 4
#define FLAG_DEVMODE 8
#define FLAG_CHECK   16
#define FLAG_FAILS   32
#define FLAG_ONE_FS  64
#define FLAG_DIR_INFO 128
#define FLAG_XATTR   256
#define FLAG_FROM_LISTFILE 512

#define BLOCKSIZE 4096

typedef struct
{
char *Path;
char *Hash;
int Size;
} TFingerprint;

ListNode *ExcludeDirectories;
TFingerprint *Prints=NULL;
dev_t StartingFS=0;
int Flags=0;

//Prototype for recursion
int ProcessItem(THash *Hash, char *Path, char *HashType, int Flags, STREAM *Output);


#define USE_XATTR

#ifdef USE_XATTR
 #include <sys/types.h>
 #include <sys/xattr.h>
#endif


int FPCompare(const void *v1, const void *v2)
{
const TFingerprint *FP1, *FP2;

FP1=(TFingerprint *) v1;
FP2=(TFingerprint *) v2;

if (! FP1->Hash) return(FALSE);
if (! FP2->Hash) return(TRUE);
if (strcmp(FP1->Hash,FP2->Hash) < 0) return(TRUE);

return(FALSE);
}

int LoadFingerprints(char *Path, ListNode *Vars)
{
STREAM *S;
char *Tempstr=NULL, *ptr;
int i=0, Blocks=1;

Prints=(TFingerprint *) calloc(BLOCKSIZE,sizeof(TFingerprint));

if (strcmp(Path,"-")==0) S=STREAMFromFD(0);
else S=STREAMOpenFile(Path,O_RDONLY);

Tempstr=STREAMReadLine(Tempstr,S);

while (Tempstr)
{
	StripTrailingWhitespace(Tempstr);
	ptr=strchr(Tempstr,' ');
	Prints[i].Hash=CopyStrLen(Prints[i].Hash,Tempstr,ptr-Tempstr);
	ptr++;
	if (isspace(*ptr)) Prints[i].Size=strtol(ptr,&ptr,10);
	while (isspace(*ptr)) ptr++;
	Prints[i].Path=CopyStr(Prints[i].Path,ptr);

	i++;
	if (i >= (Blocks * BLOCKSIZE) )
	{
		Blocks++;
		Prints=(TFingerprint *) realloc(Prints, Blocks * BLOCKSIZE * sizeof(TFingerprint));
	}

Tempstr=STREAMReadLine(Tempstr,S);
}

Tempstr=FormatStr(Tempstr,"%d",i);
SetVar(Vars,"CheckItems",Tempstr);
//qsort(Prints, Blocks * BLOCKSIZE, sizeof(TFingerprint), FPCompare);

DestroyString(Tempstr);
STREAMClose(S);
}



int CheckHashMatches(TFingerprint *Prints, char *Path, char *Hash)
{
int i;

if (! Prints) return(FALSE);



return(FALSE);
}


int FDigestHashFile(THash *Hash, char *Path)
{
STREAM *S;
char *Tempstr=NULL;
int result;

S=STREAMOpenFile(Path,O_RDONLY);
if (! S) return(FALSE);

Tempstr=SetStrLen(Tempstr,4096);

result=STREAMReadBytes(S,Tempstr,4096);
while (result > 0)
{
Hash->Update(Hash ,Tempstr, result);

result=STREAMReadBytes(S,Tempstr,4096);
}

STREAMClose(S);

DestroyString(Tempstr);


return(TRUE);
}


int IsExcludedDirectory(char *Dir)
{
ListNode *Curr;
char *mptr, *dptr;

Curr=ListGetNext(ExcludeDirectories);
while (Curr)
{
mptr=(char *) Curr->Item;
dptr=Dir;
if (*mptr!='/') 
{
mptr=basename(mptr);
dptr=basename(Dir);
}

if (fnmatch(mptr,dptr,0)==0) return(TRUE);

Curr=ListGetNext(Curr);
}


return(FALSE);
}


int ProcessDir(THash *Hash, char *Dir, char *HashType, int Flags, STREAM *Output)
{
char *Tempstr=NULL;
STREAM *S=NULL;
glob_t Glob;
int i;
int result=TRUE;

			if (strcmp(Dir,".")==0) return(TRUE);
			if (strcmp(Dir,"..")==0) return(TRUE);
			if (IsExcludedDirectory(Dir)) return(TRUE);


			if (Flags & FLAG_DIR_INFO)
			{
				Tempstr=MCopyStr(Tempstr,Dir,"/.fdigest.info",NULL);
				S=STREAMOpenFile(Tempstr,O_WRONLY|O_CREAT|O_TRUNC);	
			}
			else S=Output;

			Tempstr=MCopyStr(Tempstr,Dir,"/*",NULL);

			glob(Tempstr,0,0,&Glob);
			for (i=0; i < Glob.gl_pathc; i++)
			{
				if (! ProcessItem(Hash,Glob.gl_pathv[i],HashType,Flags,S)) result=FALSE;
			}
			globfree(&Glob);

			if (Flags & FLAG_DIR_INFO) STREAMClose(S);


DestroyString(Tempstr);

return(result);
}


//This is used to processs small pieces of data like device IDs
void ProcessData(THash *Hash, char *Path, char *Data, int DataLen, char *HashType, int Flags)
{
char *Tempstr=NULL;

		if (! Hash) 
		{
			Hash=HashInit(HashType);
			Hash->Update(Hash ,Data, DataLen);
			Hash->Finish(Hash,ENCODE_HEX,&Tempstr);
			HashDestroy(Hash);
			printf("%s %s\n",Tempstr,Path);
		} else Hash->Update(Hash ,Data, DataLen);

DestroyString(Tempstr);
}


int ProcessItem(THash *Hash, char *Path, char *HashType, int Flags, STREAM *Output)
{
char *Tempstr=NULL, *HashStr=NULL;
struct stat FStat;
STREAM *S=NULL;
int result=TRUE;

	stat(Path,&FStat);

	if (Flags & FLAG_ONE_FS)
	{
		if (StartingFS==0) StartingFS=FStat.st_dev;
		else if (FStat.st_dev != StartingFS)
		{
			 return(TRUE);
		}
	}

	if ( ! Output) 
	{
		if (! (Flags & FLAG_DIR_INFO)) S=STREAMFromFD(1);
	}
	else S=Output;


	if (S_ISDIR(FStat.st_mode))
	{
		if (Flags & FLAG_RECURSE)
		{

			if ((Flags & FLAG_DIRMODE) && (! Hash)) 
			{
				Hash=HashInit(HashType);
				
				if (! ProcessDir(Hash, Path, HashType, Flags, S)) result=FALSE;
				Tempstr=CopyStr(Tempstr,"");
				Hash->Finish(Hash,ENCODE_HEX,&HashStr);
				HashDestroy(Hash);

				Tempstr=MCopyStr(Tempstr,HashStr," ",Path,"\n",NULL);
				STREAMWriteLine(Tempstr,S);	
			}
			else if (! ProcessDir(Hash, Path, HashType, Flags,S)) result=FALSE;
		}
	}
	else if ((! (Flags & FLAG_DEVMODE)) && S_ISCHR(FStat.st_mode)) ProcessData(Hash, Path, (char *) &FStat.st_rdev, sizeof(dev_t), HashType, Flags);
	else if ((! (Flags & FLAG_DEVMODE)) && S_ISBLK(FStat.st_mode)) ProcessData(Hash, Path, (char *) &FStat.st_rdev, sizeof(dev_t), HashType, Flags);
	else if ((! (Flags & FLAG_DEVMODE)) && S_ISFIFO(FStat.st_mode)) ProcessData(Hash, Path, (char *) &FStat.st_rdev, sizeof(dev_t), HashType, Flags);
	else if ((! (Flags & FLAG_DEVMODE)) && S_ISSOCK(FStat.st_mode)) ProcessData(Hash, Path, (char *) &FStat.st_rdev, sizeof(dev_t), HashType, Flags);
	else
	{
		if (! Hash) 
		{
			Hash=HashInit(HashType);
			FDigestHashFile(Hash,Path);
			Hash->Finish(Hash,ENCODE_HEX,&HashStr);
			HashDestroy(Hash);

			if (Flags & FLAG_CHECK) 
			{
				if(CheckHashMatches(Prints,Path,HashStr)) printf("\rOKAY %s\n",Path);
				else 
				{
					printf("\rFAIL %s\n",Path);
					result=FALSE;
				}
			}
			else if (Flags & FLAG_FAILS) 
			{
				if(! CheckHashMatches(Prints,Path,HashStr)) printf("\r%s\n",Path);
			}
			else if (Flags & FLAG_XATTR)
			{
				 setxattr(Path, HashType, HashStr, StrLen(HashStr), 0);
			}
			else 
			{
				Tempstr=MCopyStr(Tempstr,HashStr," ",Path,"\n",NULL);
				STREAMWriteLine(Tempstr,S);	
			}

		} else FDigestHashFile(Hash,Path);

	}

//IF this is the top level call (Output=NULL) then flush output
if ((! Output) && S) STREAMFlush(S);

DestroyString(Tempstr);
DestroyString(HashStr);

return(result);
}


void ParseArgs(int argc,char *argv[], ListNode *Vars)
{
int i;
char *ptr;

//You never know
if (argc < 1) return;

//argv[0] might be full path to the program, or just its name
ptr=strrchr(argv[0],'/');
if (! ptr) ptr=argv[0];
else ptr++;


if (strcmp(ptr,"md5sum")==0) SetVar(Vars,"HashType","md5");
if (strcmp(ptr,"sha1sum")==0) SetVar(Vars,"HashType","sha1");
if (strcmp(ptr,"sha256sum")==0) SetVar(Vars,"HashType","sha256");
if (strcmp(ptr,"sha512sum")==0) SetVar(Vars,"HashType","sha512");
if (strcmp(ptr,"tigersum")==0) SetVar(Vars,"HashType","tiger");

for (i=1; i < argc; i++)
{
if (strcmp(argv[i],"-sha1")==0)
{
	SetVar(Vars,"HashType","sha1");
	strcpy(argv[i],"");
}
else if (strcmp(argv[i],"-sha256")==0)
{
	SetVar(Vars,"HashType","sha256");
	strcpy(argv[i],"");
}
else if (strcmp(argv[i],"-sha512")==0)
{
	SetVar(Vars,"HashType","sha512");
	strcpy(argv[i],"");
}
if (strcmp(argv[i],"-crc32")==0)
{
	SetVar(Vars,"HashType","crc32");
	strcpy(argv[i],"");
}
else if (strcmp(argv[i],"-r")==0)
{
	Flags |= FLAG_RECURSE;
	strcpy(argv[i],"");
}
else if (strcmp(argv[i],"-T")==0)
{
	Flags |= FLAG_FROM_LISTFILE;
	strcpy(argv[i],"");
}
else if (strcmp(argv[i],"-rx")==0)
{
	strcpy(argv[i],"");
	i++;
	ListAddItem(ExcludeDirectories,CopyStr(NULL,argv[i]));
	strcpy(argv[i],"");
}
else if (strcmp(argv[i],"-d")==0)
{
	Flags |= FLAG_DIRMODE | FLAG_RECURSE;
	strcpy(argv[i],"");
}
else if (strcmp(argv[i],"-dev")==0)
{
	Flags |= FLAG_DIRMODE | FLAG_DEVMODE;
	strcpy(argv[i],"");
}
else if (strcmp(argv[i],"-c")==0)
{
	Flags |= FLAG_CHECK;
	strcpy(argv[i],"");
}
else if (strcmp(argv[i],"-cf")==0)
{
	Flags |= FLAG_FAILS;
	strcpy(argv[i],"");
}
else if (strcmp(argv[i],"-fs")==0)
{
	Flags |= FLAG_ONE_FS;
	strcpy(argv[i],"");
}
else if (strcmp(argv[i],"-dir-info")==0)
{
	Flags |= FLAG_DIR_INFO;
	strcpy(argv[i],"");
}
else if (strcmp(argv[i],"-xattr")==0)
{
	Flags |= FLAG_XATTR;
	strcpy(argv[i],"");
}

}


if (Flags & (FLAG_CHECK | FLAG_FROM_LISTFILE))
{
	for (i=1; i < argc; i++)
	{
		if (StrLen(argv[i]))
		{
			SetVar(Vars,"Path",argv[i]);
			strcpy(argv[i],"");
			break;
		}
	}
}

}



int CheckHashes(ListNode *Vars)
{
char *HashStr=NULL;
char *HashType=NULL, *FingerprintsFile=NULL;
int result=TRUE, i;
int Max=0, Errors=0;
struct stat Stat;

HashType=CopyStr(HashType, GetVar(Vars,"HashType"));
FingerprintsFile=CopyStr(FingerprintsFile, GetVar(Vars,"Path"));
LoadFingerprints(FingerprintsFile, Vars);
Max=atoi(GetVar(Vars,"CheckItems"));

	for (i=0; Prints[i].Hash !=NULL; i++)
	{
		HashStr=CopyStr(HashStr,"");
		if (stat(Prints[i].Path,&Stat)==0)
		{
			HashFile(&HashStr,HashType,Prints[i].Path,ENCODE_HEX);
			if (Flags & FLAG_CHECK)
			{
			if (
						(Stat.st_size != Prints[i].Size) ||
						(strcasecmp(Prints[i].Hash,HashStr)!=0)
				)
			{
				Errors++;
				printf("\r%s  %s FAILED\n",HashStr,Prints[i].Path);
				result=FALSE;
			}
			fprintf(stderr,"\r%d of %d files checked %d changes found              ",i,Max,Errors);
			}
			else printf("%s %ld %s\n",HashStr,Stat.st_size, Prints[i].Path);
		}
		else fprintf(stderr,"\rERROR: Failed to open '%s'\n",Prints[i].Path);

	}

	DestroyString(FingerprintsFile);
	DestroyString(HashType);
	DestroyString(HashStr);

return(result); 
}


main(int argc, char *argv[])
{
char *Tempstr=NULL, *Type=NULL;
int i, result=FALSE;
ListNode *Vars;

ExcludeDirectories=ListCreate();
Vars=ListCreate();
SetVar(Vars,"HashType","md5");
SetVar(Vars,"Path","-");

ParseArgs(argc,argv,Vars);


if (
//			(! Flags & FLAG_DIR_INFO) && 
			(Flags & (FLAG_FROM_LISTFILE | FLAG_CHECK | FLAG_FAILS))
	) CheckHashes(Vars);



for (i=1; i < argc; i++)
{
	Tempstr=CopyStr(Tempstr,"");
	if (StrLen(argv[i])) result=ProcessItem(NULL,argv[i],GetVar(Vars,"HashType"),Flags,NULL);
}

DestroyString(Tempstr);

if (result) exit(0);
exit(1);
}
